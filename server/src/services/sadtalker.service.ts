import { spawn } from 'child_process';
import fs from 'fs';
import path from 'path';
import { promisify } from 'util';

const writeFile = promisify(fs.writeFile);
const readFile = promisify(fs.readFile);
const unlink = promisify(fs.unlink);

interface AvatarData {
    avatarUrl?: string;
    avatarBase64?: string;
}

class SadTalkerService {
    private sadTalkerPath = path.resolve('../../SadTalker');
    private tempDir = path.join(process.cwd(), 'temp');
    private defaultAvatarPath = path.join(process.cwd(), 'uploads', 'default-avatar.jpg');
    private uploadsDir = path.join(process.cwd(), 'uploads');
    
    constructor() {
        // 确保临时目录存在
        if (!fs.existsSync(this.tempDir)) {
            fs.mkdirSync(this.tempDir, { recursive: true });
        }
        
        // 确保上传目录存在
        if (!fs.existsSync(this.uploadsDir)) {
            fs.mkdirSync(this.uploadsDir, { recursive: true });
        }
    }

    // 生成说话视频
    generateTalkingVideo = async (
        imageBase64: string, 
        audioBase64: string,
        options: {
            enhancer?: boolean;
            preprocess?: string;
            still?: boolean;
            size?: number;
        } = {}
    ): Promise<string> => {
        const timestamp = Date.now();
        const tempImagePath = path.join(this.tempDir, `temp_image_${timestamp}.jpg`);
        const tempAudioPath = path.join(this.tempDir, `temp_audio_${timestamp}.wav`);
        const outputDir = path.join(this.tempDir, `output_${timestamp}`);
        
        try {
            // 将base64转换为文件
            const imageBuffer = Buffer.from(imageBase64, 'base64');
            const audioBuffer = Buffer.from(audioBase64, 'base64');
            
            await writeFile(tempImagePath, imageBuffer);
            await writeFile(tempAudioPath, audioBuffer);
            
            // 确保输出目录存在
            if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
            }
            
            // 构建命令参数
            const args = [
                path.join(this.sadTalkerPath, 'inference.py'),
                '--source_image', tempImagePath,
                '--driven_audio', tempAudioPath,
                '--result_dir', outputDir,
                '--preprocess', options.preprocess || 'crop',
                '--size', String(options.size || 256),
                '--batch_size', '1'
            ];
            
            if (options.enhancer) {
                args.push('--enhancer', 'gfpgan');
            }
            
            if (options.still) {
                args.push('--still');
            }
            
            console.log('Running SadTalker with args:', args);
            
            // 执行SadTalker
            const result = await this.runPythonScript(args);
            
            // 查找生成的视频文件
            const videoFiles = fs.readdirSync(outputDir).filter(file => file.endsWith('.mp4'));
            
            if (videoFiles.length === 0) {
                throw new Error('No video file generated by SadTalker');
            }
            
            const videoPath = path.join(outputDir, videoFiles[0]);
            const videoBuffer = await readFile(videoPath);
            const videoBase64 = videoBuffer.toString('base64');
            
            // 清理临时文件
            await this.cleanup([tempImagePath, tempAudioPath, outputDir]);
            
            return videoBase64;
            
        } catch (error) {
            // 确保清理临时文件
            await this.cleanup([tempImagePath, tempAudioPath, outputDir]);
            console.error('SadTalker generation failed:', error);
            throw error;
        }
    };
    
    // 运行Python脚本
    private runPythonScript = (args: string[]): Promise<string> => {
        return new Promise((resolve, reject) => {
            const pythonProcess = spawn('python', args, {
                cwd: this.sadTalkerPath,
                stdio: ['pipe', 'pipe', 'pipe']
            });
            
            let stdout = '';
            let stderr = '';
            
            pythonProcess.stdout.on('data', (data) => {
                stdout += data.toString();
                console.log('SadTalker stdout:', data.toString());
            });
            
            pythonProcess.stderr.on('data', (data) => {
                stderr += data.toString();
                console.error('SadTalker stderr:', data.toString());
            });
            
            pythonProcess.on('close', (code) => {
                if (code === 0) {
                    resolve(stdout);
                } else {
                    reject(new Error(`SadTalker process exited with code ${code}. stderr: ${stderr}`));
                }
            });
            
            pythonProcess.on('error', (error) => {
                reject(new Error(`Failed to start SadTalker process: ${error.message}`));
            });
            
            // 设置超时（5分钟）
            setTimeout(() => {
                pythonProcess.kill();
                reject(new Error('SadTalker process timeout'));
            }, 300000);
        });
    };
    
    // 清理临时文件和目录
    private cleanup = async (paths: string[]) => {
        for (const filePath of paths) {
            try {
                if (fs.existsSync(filePath)) {
                    const stat = fs.statSync(filePath);
                    if (stat.isDirectory()) {
                        fs.rmSync(filePath, { recursive: true, force: true });
                    } else {
                        await unlink(filePath);
                    }
                }
            } catch (error) {
                console.warn(`Failed to cleanup ${filePath}:`, error);
            }
        }
    };
    
    // 检查SadTalker服务状态
    checkServiceHealth = async (): Promise<boolean> => {
        try {
            // 检查SadTalker目录是否存在
            if (!fs.existsSync(this.sadTalkerPath)) {
                console.error('SadTalker directory not found:', this.sadTalkerPath);
                return false;
            }
            
            // 检查inference.py是否存在
            const inferencePath = path.join(this.sadTalkerPath, 'inference.py');
            if (!fs.existsSync(inferencePath)) {
                console.error('SadTalker inference.py not found:', inferencePath);
                return false;
            }
            
            return true;
        } catch (error) {
            console.error('SadTalker health check failed:', error);
            return false;
        }
    };
    
    // 获取默认头像
    getDefaultAvatar = async (): Promise<AvatarData> => {
        try {
            // 首先检查是否有用户上传的默认头像
            if (fs.existsSync(this.defaultAvatarPath)) {
                const buffer = await readFile(this.defaultAvatarPath);
                return {
                    avatarUrl: `/uploads/default-avatar.jpg`,
                    avatarBase64: buffer.toString('base64')
                };
            }
            
            // 尝试多个可能的默认头像路径
            const possiblePaths = [
                path.join(this.sadTalkerPath, 'examples', 'source_image', 'full_body_1.png'),
                path.join(this.sadTalkerPath, 'examples', 'source_image', 'full_body_2.png'),
                path.join(this.sadTalkerPath, 'examples', 'source_image', 'art_0.png'),
                path.join(this.sadTalkerPath, 'examples', 'source_image', 'art_1.png'),
            ];
            
            for (const avatarPath of possiblePaths) {
                if (fs.existsSync(avatarPath)) {
                    console.log(`Using default avatar: ${avatarPath}`);
                    const buffer = fs.readFileSync(avatarPath);
                    return {
                        avatarBase64: buffer.toString('base64')
                    };
                }
            }
            
            // 如果所有默认头像都不存在，返回占位符
            console.warn('No default avatar found, using placeholder');
            return {
                avatarBase64: this.createPlaceholderAvatar()
            };
        } catch (error) {
            console.error('Failed to get default avatar:', error);
            return {
                avatarBase64: this.createPlaceholderAvatar()
            };
        }
    };

    // 上传默认头像
    uploadDefaultAvatar = async (avatarBase64: string): Promise<{ avatarUrl: string }> => {
        try {
            const imageBuffer = Buffer.from(avatarBase64, 'base64');
            await writeFile(this.defaultAvatarPath, imageBuffer);
            
            console.log('Default avatar uploaded successfully:', this.defaultAvatarPath);
            return {
                avatarUrl: `/uploads/default-avatar.jpg`
            };
        } catch (error) {
            console.error('Failed to upload default avatar:', error);
            throw new Error('Failed to upload default avatar');
        }
    };

    // 删除默认头像
    deleteDefaultAvatar = async (): Promise<void> => {
        try {
            if (fs.existsSync(this.defaultAvatarPath)) {
                await unlink(this.defaultAvatarPath);
                console.log('Default avatar deleted successfully');
            }
        } catch (error) {
            console.error('Failed to delete default avatar:', error);
            throw new Error('Failed to delete default avatar');
        }
    };

    // 移除用户头像相关方法 - 现在只支持管理员管理的默认头像
    // storeUserAvatar、getUserAvatar、deleteUserAvatar 方法已删除
    
    // 创建占位符头像（简单的base64图片）
    private createPlaceholderAvatar = (): string => {
        // 这是一个1x1像素的透明PNG图片的base64编码
        return 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';
    };
}

export const sadTalkerService = new SadTalkerService(); 